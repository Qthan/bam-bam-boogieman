class BoogieLanguage
  
  prechigh
    left 'forall' 'exists'
    left 'old'
    nonassoc '[' ']'
    nonassoc '!'
    left '*' '/' '%'
    left '+' '-'
    left '++'
    left '==' '!=' '<' '>' '<=' '>=' '<:'
    left '&&'
    left '||'
    left '==>'
    left '<==>'
    left 'if' 'then' 'else'
    left ':'
    nonassoc '(' ')'
  preclow
  
  options no_result_var

  token IDENTIFIER NUMBER BITVECTOR STRING BVTYPE
  
rule 
  target: program
      
  ident: IDENTIFIER { Identifier.new val[0] }
  idents: ident { [val[0]] } | ident ',' idents { [val[0]] + val[2] }
  idents_opt: { [] } | idents
      
  literal: 
    bool_lit    { BooleanLiteral.new val[0] }
    | BITVECTOR  { BitvectorLiteral.new val[0] }
    | NUMBER     { IntegerLiteral.new val[0] }      
  bool_lit: 'true' { true } | 'false' { false }

  string: STRING
  
  type:
    type_atom
    | map_type
    | ident tc_args { CustomType.new val[0], val[1] }
  
  type_atom:
    'bool' { Type::Boolean }
    | 'int' { Type::Integer }
    | BVTYPE { BitvectorType.new val[0] }
    | '(' type ')' { val[1] }
    
  map_type: type_args '[' types ']' type { MapType.new val[0], val[2], val[4] }

  tc_args:
    { [] }
    | type_atom tc_args { [val[0]] + val[1] }
    | ident tc_args { [CustomType.new(val[0],val[1])] }
    | map_type { [val[0]] }
    
  types: type { [val[0]] } | type ',' types { [val[0]] + val[2] }
    
  type_args: { [] } | '<' idents '>' { val[1] }

  typed_id: ident ':' type { [val[0],val[2]] }
  typed_ids: typed_id { [val[0]] } | typed_id ',' typed_ids  { [val[0]] + val[2] }
  typed_ids_opt: { [] } | typed_ids
  
  expr: expr '<==>' expr  { BinaryExpression.new val }
      | expr '==>' expr   { BinaryExpression.new val }
      | expr '||' expr    { BinaryExpression.new val }
      | expr '&&' expr    { BinaryExpression.new val }
      | expr '==' expr    { BinaryExpression.new val }
      | expr '!=' expr    { BinaryExpression.new val }
      | expr '<' expr     { BinaryExpression.new val }
      | expr '>' expr     { BinaryExpression.new val }
      | expr '<=' expr    { BinaryExpression.new val }
      | expr '>=' expr    { BinaryExpression.new val }
      | expr '<:' expr    { BinaryExpression.new val }
      | expr '++' expr    { BinaryExpression.new val }
      | expr '+' expr     { BinaryExpression.new val }
      | expr '-' expr     { BinaryExpression.new val }
      | expr '*' expr     { BinaryExpression.new val }
      | expr '/' expr     { BinaryExpression.new val }
      | expr '%' expr     { BinaryExpression.new val }
      | '!' expr          { LogicalNegation.new val[1] }
      | '-' expr          { ArithmeticNegation.new val[1] }
      | expr '[' exprs ']' { MapSelect.new val[0], val[2] }
      | expr '[' exprs ':=' expr ']' { MapUpdate.new val[0], val[2], val[4] }
      | expr '[' NUMBER ':' NUMBER ']' { BitvectorExtract.new val[0], val[2], val[4] }
      | literal       
      | IDENTIFIER '(' exprs_opt ')' { FunctionApplication.new val[0], val[2] }
      | IDENTIFIER   { Identifier.new val[0] }
      | 'old' '(' expr ')' { OldExpression.new val[2] }
      | '(' quantifier type_args typed_ids '::' ants expr ')' { 
        QuantifiedExpression.new val[1], val[2], val[3], val[5], val[6] 
      }
      | '(' expr ')'  { val[1] }
      
  exprs: expr { [val[0]] } | expr ',' exprs { [val[0]] + val[2] }
  exprs_opt: { [] } | exprs
  
  quantifier: 'forall' | 'exists'

  attr: '{:' ident enss_opt '}' { Attribute.new val[1], val[2] }
  attrs: { [] } | attr attrs { [val[0]] + val[1] }
  trigger: '{' exprs '}' { Trigger.new val[1] }
  ant: attr | trigger
  ants: { [] } | ant ants { [val[0]] + val[1] }

  ens: expr | string
  enss: ens { [val[0]] } | ens ',' enss { [val[0]] + val[2] }
  enss_opt: { [] } | enss
  
  stmt:
    'assert' expr ';' { AssertStatement.new val[1] }
    | 'assume' expr ';' { AssumeStatement.new val[1] }
    | 'havoc' idents ';' { HavocStatement.new val[1] }
    | lhss ':=' exprs ';' { AssignStatement.new val[0], val[2] }
    | 'call' ident '(' exprs_opt ')' ';' { CallStatement.new val[1], val[3] }
    | 'call' idents ':=' ident '(' exprs_opt ')' ';' { CallStatement.new val[3], val[5], val[1] }
    | 'call' 'forall' ident '(' wc_exprs_opt ')' ';' { CallStatement.new val[2], val[4], nil }
    | if_stmt
    | 'while' '(' wc_expr ')' loop_invs block { WhileStatement.new val[2], val[4], val[5] }
    | 'break' idents_opt ';' { BreakStatement.new val[1] }
    | 'return' ';' { Statement::Return }
    | 'goto' idents ';' { GotoStatement.new val[1] }
  
  if_stmt: 'if' '(' wc_expr ')' block else_stmt { IfStatement.new val[2], val[4], val[5] }
  else_stmt: { nil } | 'else' block { val[1] } | 'else' if_stmt { val[1] }

  lhs: ident selects { val[1].empty? ? val[0] : val[1].reduce(val[0]){|m,x| MapSelect.new m, x} }
  lhss: lhs { [val[0]] } | lhs ',' lhss { [val[0]] + val[2] }

  select: '[' exprs ']' { val[1] }
  selects: { [] } | select selects { [val[0]] + val[1] }

  wc_expr: expr | '*' { Expression::Wildcard }
  wc_exprs: wc_expr { [val[0]] } | wc_expr ',' wc_exprs { [val[0]] + val[2] }
  wc_exprs_opt: { [] } | wc_exprs
  
  loop_inv: free_opt 'invariant' expr ';' { LoopInvariant.new val[0], val[2] }
  loop_invs: { [] } | loop_inv loop_invs { [val[0]] + val[1] }
  free_opt: { false } | 'free' { true }
  
  lstmt: stmt { [[],val[0]] } | ident ':' lstmt { [[val[0]]+val[2][0],val[2][1]] }
  lstmts: { [] } | lstmt lstmts { [val[0]] + val[1] }
  lempty: { [] } | ident ':' lempty { [[val[0]] + val[2],nil] }
  stmt_list: lstmts lempty { val[0] + val[1] }
  block: '{' stmt_list '}' { Block.new val[1] }
  
  decl:
    type_decl
    | const_decl
    | func_decl
    | axiom_decl
    | var_decl
    | proc_decl
    | impl_decl
  decls: { [] } | decl decls { [val[0]] + val[1] }

  type_decl: 'type' attrs finite_opt ident tc_params type_syn ';' { 
    if val[5] && val[2]
      abort "Illegal declaration of type #{([val[3]] + val[4]) * " "}"
    end
    TypeDeclaration.new val[3], val[4], val[1], val[2], val[5] 
  }
  finite_opt: { false } | 'finite' { true }
  tc_params: { [] } | ident tc_params { [val[0]] + val[1] }
  type_syn: { nil } | '=' type { val[1] }

  const_decl: 'const' attrs unique_opt idents ':' type order_spec ';' {
    ConstantDeclaration.new val[3], val[5], val[1], val[2], val[6]
  }
  unique_opt: { false } | 'unique' { true }
  order_spec: parent_info complete_opt { [val[0],val[1]] }
  parent_info: { nil } | '<:' parent_edges_opt { val[1] }
  parent_edge: unique_opt ident { [val[0],val[1]] }
  parent_edges: parent_edge { [val[0]] } | parent_edge ',' parent_edges { [val[0]] + val[2] }
  parent_edges_opt: { [] } | parent_edges
  complete_opt: { false } | 'complete' { true }

  func_decl: 'function' attrs ident type_args '(' fargs_opt ')' 'returns' '(' farg ')' fbody {
    FunctionDeclaration.new val[2], val[3], val[5], val[9], val[11], val[1]
  }
  farg: ident ':' type { [val[0],val[2]] } | type { [nil,val[0]] }
  fargs: farg { [val[0]] } | farg ',' fargs { [val[0]] + val[2] }
  fargs_opt: { [] } | fargs
  fbody: ';' { nil } | '{' expr '}' { val[1] }

  axiom_decl: 'axiom' attrs expr ';' { AxiomDeclaration.new val[2], val[1] }

  var_decl: 'var' attrs idents ':' type where_clause ';' {
    VariableDeclaration.new val[2], val[4], val[5], val[1]
  }
  var_decls: { [] } | var_decl var_decls { [val[0]] + val[1] }
  where_clause: { nil } | 'where' expr { val[1] }

  proc_decl: 'procedure' attrs ident type_args '(' typed_ids_opt ')' out_params pspec {
    ProcedureDeclaration.new val[1], val[2], val[3], val[5], val[7], val[8][0], val[8][1]
  }
  out_params: { [] } | 'returns' '(' typed_ids ')' { val[2] }
  pspec: ';' specs { [val[1],nil] } | specs pbody { [val[0],val[1]] }
  pbody: '{' var_decls stmt_list '}' { [val[1],val[2]] }

  spec: 
    free_opt 'requires' expr ';' { RequiresClause.new val[0], val[2] }
    | free_opt 'modifies' idents ';' { ModifiesClause.new val[0], val[2] }
    | free_opt 'ensures' expr ';' { EnsuresClause.new val[0], val[2] }
  specs: { [] } | spec specs { [val[0]] + val[1] }

  impl_decl: 'implementation'
  
  program: decls { Program.new val[0] }
end

---- header
require_relative 'lexer.rex'
require_relative 'ast/type'
require_relative 'ast/expression'
require_relative 'ast/specification'
require_relative 'ast/statement'
require_relative 'ast/declaration'
require_relative 'ast/program'
include Bpl::AST

---- inner
def parse(input)
  scan_str(input)
end

---- footer
